<!-- _layouts/post.html -->
---
layout: default
---
<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Solver for Flow game</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2015-02-05T00:00:00-05:00" itemprop="datePublished">Feb 5, 2015
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>I have been playing this android game <a href="https://play.google.com/store/apps/details?id=com.bigduckgames.flow&amp;hl=en">Flow</a>.  I also ran into a post in a game developer forum that someone asked for a solver to find the solution of a game.  So I thought it would be an interesting problem to solve.</p>

<p>The game is really simple.  The starting map is an N-by-M grid with a number of pairs of color dots on it.  The goal is the game is to connect the pairs of dots with the same color, and fill up all the grids on the map.</p>

<p>The codes can be found <a href="https://github.com/ctawong/flowSolver">here</a>.</p>

<h2 id="defining-a-game-map">Defining a game map</h2>

<p>First I define a graph class to store and generate a game map.  The map is represented by a 2D N-by-M matrix.  An element 0 means an empty spot.  Each color is presented by an integer 1 or higher.  The Graph class also has a method for getting the neighbors of a given position.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="k">class</span> <span class="nc">Graph</span><span class="p">():</span>
    <span class="s">''' class for storing and generating game maps '''</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numRow</span><span class="p">,</span> <span class="n">numCol</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="nb">map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">numRow</span><span class="p">,</span><span class="n">numCol</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s">'int32'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numRow</span> <span class="o">=</span> <span class="n">numRow</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numCol</span> <span class="o">=</span> <span class="n">numCol</span>

    <span class="k">def</span> <span class="nf">generateRandom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numColors</span><span class="p">,</span> <span class="n">dotsPerColor</span><span class="p">):</span>
        <span class="s">''' generate random positions of color dots '''</span>
        <span class="c1">#np.random.seed(100)
</span>        <span class="n">dots</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">numColors</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dotsPerColor</span><span class="p">):</span>
                <span class="n">done</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">while</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>
                    <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numRow</span><span class="p">)</span>
                    <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numCol</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
                        <span class="n">done</span> <span class="o">=</span> <span class="bp">True</span>
        
    <span class="k">def</span> <span class="nf">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="s">''' return neigbors of position pos marked with colors listed in include '''</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="n">neig</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">npos</span> <span class="ow">in</span>  <span class="p">[</span><span class="n">pos</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">pos</span><span class="o">+</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos</span><span class="o">+</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]]:</span>
            <span class="k">if</span> <span class="n">npos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numRow</span><span class="p">)</span> <span class="ow">and</span> <span class="n">npos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numCol</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">include</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">npos</span><span class="p">)]):</span>  <span class="c1"># check with valid neigbor color 
</span>                    <span class="n">neig</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">npos</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">neig</span>
</code></pre></div></div>

<p><br /></p>
<h2 id="defining-path-structure">Defining path structure</h2>

<p>The first problem is to create a way to represent paths starting from a color dot.  It may end on a dead end, or end by connecting a matching color dot.  Below I defined a node class to represent a point of a path.  If more than one of it’s neighbor is empty, the path can take any of them as the next step.  So the node class can have a number of children, which are also nodes, as it’s next steps.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">node</span><span class="p">():</span>
    <span class="s">''' data structure for tree nodes '''</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">children</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>  <span class="c1"># coordinate tuple
</span>        <span class="k">if</span> <span class="n">children</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>  <span class="c1"># list of nodes
</span>        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span> <span class="c1"># a node or None if head node
</span>    <span class="k">def</span> <span class="nf">addChild</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
</code></pre></div></div>

<p><br />
##Getting paths</p>

<p>As my first shot, I consider a “brute force” approach that finds all possible paths starting from a color dot.  It always considers the initial map with only color dots, i.e. without any spots ocuppied by any paths.  Starting from a color dot, a path can either end on a dead end, or end by connecting another matching color dot.  As you can imagine, almost always there are more than 1 paths that can connect two matching color dots, especially when you consider the fact that we are acting on the initial empty game map.</p>

<p>The walk function generates all possible paths from a color dot.  It first create a head node designating the position of the starting color dot.  It then populates the next possible moves as it’s child nodes. The process repeats recursively until all possible paths are found.  It other words, it generates a tree for all possible paths.</p>

<p>The getPaths function generates a list of paths, in the form of series of coordinates, from the tree generated by the walk function.</p>

<p>If we do the walk and getPaths functions for all colors, we would find a set of all possible paths for each color.  By comparing them, we will be able to a solution that connects all matching dots while filling up all the empty spots, if that solution ever exists.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">walk</span><span class="p">(</span><span class="n">current_node</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">endColor</span><span class="p">):</span>
    <span class="s">''' recursively walk on the graph to create a tree at ends either at dead end or endColor'''</span>
    <span class="k">for</span> <span class="nb">next</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">current_node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">endColor</span><span class="p">]):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">(</span><span class="nb">next</span><span class="p">,</span> <span class="n">current_node</span><span class="p">):</span>
            <span class="n">next_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="nb">next</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">current_node</span><span class="p">)</span>
            <span class="n">current_node</span><span class="o">.</span><span class="n">addChild</span><span class="p">(</span><span class="n">next_node</span><span class="p">)</span>
            <span class="k">if</span>  <span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="nb">next</span><span class="p">]</span> <span class="o">!=</span> <span class="n">endColor</span><span class="p">:</span>
                <span class="n">walk</span><span class="p">(</span><span class="n">next_node</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">endColor</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">visited</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">current_node</span><span class="p">):</span>
    <span class="s">''' trace back from current node to head.  return True if position is visited '''</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">current_node</span>
    <span class="k">while</span> <span class="n">n</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">position</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>

<span class="k">def</span> <span class="nf">getPaths</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">endColor</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">paths</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="s">'''
    Return all paths starting from node that ends at endColor.
    Usage: paths = getPaths(head_node, endColor, graph)
    '''</span>
    <span class="k">if</span> <span class="n">paths</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">paths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">path</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">]</span> <span class="o">==</span> <span class="n">endColor</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="c1"># record path ends at the right color
</span>    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
        <span class="n">getPaths</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">endColor</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">path</span><span class="p">))</span> <span class="c1"># list(path) to create new copy of path
</span>    <span class="k">return</span> <span class="n">paths</span>
</code></pre></div></div>

<p><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">getPathsAllColor</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="s">''' 
    Get all possible paths from all color dots. 
    Return as dictionary of colors
    '''</span>
    <span class="n">paths</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">color</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="o">==</span><span class="n">color</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">head_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
            <span class="n">walk</span><span class="p">(</span><span class="n">head_node</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span>
            <span class="n">paths</span><span class="p">[</span><span class="n">color</span><span class="p">]</span> <span class="o">=</span> <span class="n">getPaths</span><span class="p">(</span><span class="n">head_node</span><span class="p">,</span><span class="n">color</span><span class="p">,</span> <span class="n">graph</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">paths</span>


<span class="k">def</span> <span class="nf">checkPaths</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">'bool'</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
                <span class="n">m</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>    
    <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="nb">all</span><span class="p">():</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

<span class="k">def</span> <span class="nf">showPath</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
    <span class="n">mm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">p</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
            <span class="n">mm</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">print</span> <span class="n">mm</span>
        
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="k">def</span> <span class="nf">solve_bruteForce</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span> <span class="o">*</span><span class="p">(</span><span class="n">paths</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">)</span> <span class="p">):</span>
        <span class="k">if</span> <span class="n">checkPaths</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">p</span>
</code></pre></div></div>

<p><br />
##An example</p>

<p>Here’s an example I took out from the game.  I first reproduce the 5-by-5 game map.  There are 5 pairs of color dots, represented by number 1 to 5.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="k">print</span> <span class="n">graph</span><span class="o">.</span><span class="nb">map</span>
</code></pre></div></div>

<p><br /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Output:
[[0 0 1 2 3]
 [0 0 0 0 0]
 [1 0 0 5 0]
 [0 0 0 4 3]
 [2 5 0 0 4]]

</code></pre></div></div>

<p><br />
Then we use getPathsAllColor function to get all possible paths for all colors, and use solve_bruteForce generator function to find a soluton.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">paths</span> <span class="o">=</span> <span class="n">getPathsAllColor</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>  <span class="c1"># find all possible paths for all colors
</span><span class="n">p</span> <span class="o">=</span> <span class="n">solve_bruteForce</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">graph</span><span class="p">)</span>  <span class="c1"># solution generator
</span><span class="n">showPath</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="nb">next</span><span class="p">(),</span> <span class="n">graph</span><span class="p">)</span>
</code></pre></div></div>

<p><br /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Output:
[[1 1 1 2 3]
 [1 2 2 2 3]
 [1 2 5 5 3]
 [2 2 5 4 3]
 [2 5 5 4 4]]

</code></pre></div></div>

<p><br />
Another example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
<span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">graph</span><span class="o">.</span><span class="nb">map</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span>
<span class="k">print</span> <span class="n">graph</span><span class="o">.</span><span class="nb">map</span>
</code></pre></div></div>

<p><br /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Output:
[[1 0 3 0 0 6]
 [2 0 1 2 0 0]
 [0 0 0 0 0 0]
 [0 4 5 0 0 0]
 [0 5 0 3 4 0]
 [0 0 0 0 0 6]]

</code></pre></div></div>

<p><br /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">paths</span> <span class="o">=</span> <span class="n">getPathsAllColor</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>  <span class="c1"># find all possible paths for all colors
</span><span class="n">p</span> <span class="o">=</span> <span class="n">solve_bruteForce</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">graph</span><span class="p">)</span>  <span class="c1"># solution generator
</span><span class="n">showPath</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="nb">next</span><span class="p">(),</span> <span class="n">graph</span><span class="p">)</span>
</code></pre></div></div>

<p><br /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Output:
[[1 1 3 3 3 6]
 [2 1 1 2 3 6]
 [2 2 2 2 3 6]
 [4 4 5 3 3 6]
 [4 5 5 3 4 6]
 [4 4 4 4 4 6]]

</code></pre></div></div>

<p><br /></p>
<h2 id="final-thoughts">Final thoughts</h2>

<p>Although it works, the brute force search approach is pretty slow.  It would be interesting to find other search methods to improve speed.</p>

<p>The code-based method to construct the game map is not user-friendly.  Some kind of GUI would be a great improvement.</p>

<p>Another drawback is that this program does not work when there are more than 1 pair of color dots with the same color.</p>

  </div><a class="u-url" href="/flow_solver.html" hidden></a>
</article>
